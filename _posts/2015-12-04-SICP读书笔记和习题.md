---
layout: post
title:  "SICP读书笔记和习题"
date:   2015-12-04 23:18:00
categories: sicp 习题
---
这是一篇关于sicp的习题和读书笔记，由于题目太多，只能慢慢做，慢慢更新；日拱一卒,功不唐捐。

![图1](https://raw.githubusercontent.com/RuiKQ/RuiKQ.github.io/master/assets/images/sicp/sicp.png)

####第1章 构造过程抽象
----
####第2章 构造数据抽象
#####练习2.25
这题还是比较简单的，最后一个简直丧心病狂
{% highlight ruby %}
(define x (list 1 3 (5 7) 9))
(define y (list ((7))))
(define z (list (1 (2 (3 (4 (5 (6 7))))))))
(car (cdr (car (cdr (cdr x)))))
(car (car y))
(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr z))))))))))))
{% endhighlight %}
#####练习2.26
{% highlight ruby %}
(define x (list 1 2 3))
(define y (list 4 5 6))

(append x y) = (1 2 3 4 5 6)
(cons x y)   = ((1 2 3) 4 5 6)
(list x y)   = ((1 2 3) (4 5 6))
{% endhighlight %}
#####练习2.27
这题只需要在是序列的元素师序列的情况下加一层resverse递归就可以了
{% highlight ruby %}
;空的数组
(define nil '()) 
(define (deep-reverse items) 
  (define (iter items result) 
    (if (null? items) 
        result 
        (iter (cdr items) (cons (if (pair? (car items))
        (iter (car items) nil)
        (car items)) result))))
  (iter items nil)) 
 
;测试
(define x (list (list 1 2) (list 3 4)))
(deep-reverse x)
;((4 3) (2 1))
{% endhighlight %}
#####练习2.28
这题的思路是对左右子树分别进行递归，再进行append
{% highlight ruby %}
(define nil '())

(define (fringe items)
	(cond ((null? items) nil)
		  ((not (pair? items)) (list items))
		  (else (append (if (null? (car items))
		  					(list (car items))
		  					(fringe (car items)))
						(fringe (cdr items))))))
;测试
(define x (list (list 1 2) (list 3 4)))
(fringe x)
;(1 2 3 4)
{% endhighlight %}
#####练习2.29
