---
layout: post
title:  "SICP读书笔记和习题"
date:   2015-12-04 23:18:00
categories: sicp 习题
---
这是一篇关于sicp的习题和读书笔记，主要是记录一些心得和习题的解法，虽然习题答案网上有很多，但我还是想自己建一个wiki，一是为了让自己的代码有所归类，二是能够对书中的内容有个阶段性的总结。由于题目太多，只能慢慢做，慢慢更新；日拱一卒,功不唐捐。

![图1](https://raw.githubusercontent.com/RuiKQ/RuiKQ.github.io/master/assets/images/sicp/sicp.png)

####第1章 构造过程抽象
----
####第2章 构造数据抽象
#####练习2.25
这题还是比较简单的，最后一个简直丧心病狂
{% highlight scheme %}
(define x (list 1 3 (5 7) 9))
(define y (list ((7))))
(define z (list (1 (2 (3 (4 (5 (6 7))))))))
(car (cdr (car (cdr (cdr x)))))
(car (car y))
(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr z))))))))))))
{% endhighlight %}
#####练习2.26
{% highlight scheme %}
(define x (list 1 2 3))
(define y (list 4 5 6))

(append x y) = (1 2 3 4 5 6)
(cons x y)   = ((1 2 3) 4 5 6)
(list x y)   = ((1 2 3) (4 5 6))
{% endhighlight %}
#####练习2.27
这题只需要在是序列的元素师序列的情况下加一层resverse递归就可以了
{% highlight scheme %}
;空的数组
(define nil '()) 
(define (deep-reverse items) 
  (define (iter items result) 
    (if (null? items) 
        result 
        (iter (cdr items) (cons (if (pair? (car items))
        (iter (car items) nil)
        (car items)) result))))
  (iter items nil)) 
 
;测试
(define x (list (list 1 2) (list 3 4)))
(deep-reverse x)
;((4 3) (2 1))
{% endhighlight %}
#####练习2.28
这题的思路是对左右子树分别进行递归，再进行append
{% highlight scheme %}
(define nil '())

(define (fringe items)
	(cond ((null? items) nil)
		  ((not (pair? items)) (list items))
		  (else (append (if (null? (car items))
		  					(list (car items))
		  					(fringe (car items)))
						(fringe (cdr items))))))
;测试
(define x (list (list 1 2) (list 3 4)))
(fringe x)
;(1 2 3 4)
{% endhighlight %}
#####练习2.29
a)由于make-mobile和make-branch都是使用list所以right-branch和branch-structure需要在一次cdr解包后再进行一次car解包
{% highlight scheme %}
;题中函数
(define (make-mobile left right)
	(list left right))
(define (make-branch length structure)
	(list length structure))

(define (left-branch mobile)
	(car mobile))

(define (right-branch mobile)
	(car (cdr mobile)))

(define (branch-length branch)
    (car branch))

(define (branch-structure branch)
    (car (cdr branch)))
{% endhighlight %}
b)总的重量等于每个左分支的重量加上右分支的重量，一个分支如果structure是一个重量那么structure就是它的重量，如果是一个分支就是分支的重量。
{% highlight scheme %}
;计算每个branch的weight
(define (branch-weight branch)
	(if (pair? (branch-structure branch))
		(total-weight (branch-structure branch))
		(branch-structure branch)))
;总的weight=左branch的weight+右branch的weight
(define (total-weight mobile)
	(+ (branch-weight (left-branch mobile))
	   (branch-weight (right-branch mobile))))
{% endhighlight %}
c)这一问的算法其实和b差不多，需要递归检查每个分支；一个二叉活动体是否平衡需要满足两个条件，首先是左分支的重量等于右分支的重量，其次每个分支上的每个左右子分支的重量都要相等。
{% highlight scheme %}
;力矩等于长度乘以分支上的重量
(define (branch-torque branch)
	(* (branch-length branch)
	   (branch-weight branch)))
;一个分支是否是平衡的
(define (branch-balance? branch)
	(if (pair? (branch-structure branch))
		(balance? (branch-structure branch))
		#t))

(define (balance? mobile)
	(and (branch-balance? (left-branch mobile))
		 (branch-balance? (right-branch mobile))
		 (= (branch-torque (right-branch mobile))
		 	(branch-torque (left-branch mobile)))))
{% endhighlight %}
d)list变为cons只是底层的数据结构改变了，上层的逻辑处理方式并没有改变，所以只需要改变a的right-branch和branch-structure方法的解包方式就可以，改为一次cdr就可以。
#####练习2.30
只需改变数据结构的遍历方式就可以了
{% highlight scheme %}
(define nil '())
(define (square x) (* x x))
;直接定义
(define (square-tree tree f)
	(cond ((null? tree) nil)
		  ((not (pair? tree)) (f tree))
		  (else (cons (square-tree (car tree) f)
		  			  (square-tree (cdr tree) f)))))
;map方式
(define (square-tree tree f)
    (map (lambda (sub-tree)
             (if (pair? sub-tree)  
                 (square-tree sub-tree f)
                 (f sub-tree)))
         tree))
;测试
(define x (list 1 (list 2 (list 3 4) 5) (list 6 7)))
(square-tree x square)
{% endhighlight %}
#####练习2.31
其实在做30题时就已经将函数抽象出来了
{% highlight scheme %}
(define (square x) (* x x))
(define (tree-map f tree)
	(map (lambda (sub-tree)
             (if (pair? sub-tree)
                 (square-tree sub-tree f)
                 (f sub-tree)))
         tree))
(define (square-tree tree) (tree-map square tree))
{% endhighlight %}
#####练习2.32
s的子集等于(cdr s)的子集加上(cdr s)中每个元素的append(car s)的集合
这是典型的分治法，将一个大问题分解为多个小问题，和那个换零钱问题有点类似
问题的演算过程是这样的（演算来自[http://community.schemewiki.org/?sicp-ex-2.32](http://community.schemewiki.org/?sicp-ex-2.32)）
{% highlight scheme %}
(subsets '(1 2 3))
rest ← (subsets '(2 3))
       rest ← (subsets '(3))
              rest ← (subsets '())
                     '(())
              (append '(()) (map ⟨…⟩ '(())))
              '(() (3))
       (append '(() (3)) (map ⟨…⟩ '(() (3))))
       '(() (3) (2) (2 3))
(append '(() (3) (2) (2 3)) (map ⟨…⟩ '(() (3) (2) (2 3))))
'(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))
{% endhighlight %}
{% highlight scheme %}
(define (subsets s)
	(if (null? s) 
		(list '())
		(let ((rest (subsets (cdr s))))
			(append rest (map (lambda (sub-s)
								 (cons (car s) sub-s))
							  rest)))))
{% endhighlight %}